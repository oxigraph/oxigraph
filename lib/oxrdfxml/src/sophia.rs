//! Sophia trait implementation of OxTTL types.
//!
//! Sophia [parsers](sophia_api::parser) and [serializers](sophia_api::serializer) are expected to be reusable,
//! while OxRDFXML parsers and serializer are "one-shot" (they are consumed by the `parse`/`serialize` method).
//! So this module introduces simple "factory" types,
//! which implement the Sophia traits:
//! * [`RdfXmlParserFactory`]
//! * [`RdfXmlSerializerFactory`]
//!
//! Each of this type is a simple wrapper around a closure producing the corresponding OxTTL parser or serializer.
//! For serializers, they also expect the "sink" (usually a [`std::io::Write`]) to which the serializer must write.

use std::io::{Read, Write};

use oxrdf::sophia::TripleExt;
use sophia_api::{
    parser::TripleParser,
    serializer::{Stringifier, TripleSerializer},
    source::{StreamError, StreamResult, TripleSource},
};
use thiserror::Error;

use crate::{FromReadRdfXmlReader, RdfXmlParser, RdfXmlSerializer};

/// Wraps a [`RdfXmlParser`]-producing function, and implements [`sophia_api::parser::TripleParser`].
pub struct RdfXmlParserFactory<F: Fn() -> RdfXmlParser>(pub F);

impl<F, R> TripleParser<R> for RdfXmlParserFactory<F>
where
    F: Fn() -> RdfXmlParser,
    R: Read,
{
    type Source = FromReadRdfXmlReader<R>;

    fn parse(&self, data: R) -> Self::Source {
        (self.0)().parse_read(data)
    }
}

/// Wraps a [`RdfXmlParser`]-producing function and a [`Write`],
/// and implements [`sophia_api::parser::QuadParser`].
///
/// To get a [`Stringifier`], pass an empty `Vec<u8>` as the 2nd member.
pub struct RdfXmlSerializerFactory<F: Fn() -> RdfXmlSerializer, W: Write>(pub F, pub W);

impl<F, W> TripleSerializer for RdfXmlSerializerFactory<F, W>
where
    F: Fn() -> RdfXmlSerializer,
    W: Write,
{
    type Error = SerializeError;

    fn serialize_triples<TS>(
        &mut self,
        mut source: TS,
    ) -> StreamResult<&mut Self, TS::Error, Self::Error>
    where
        TS: TripleSource,
        Self: Sized,
    {
        let mut writer = (self.0)().serialize_to_write(&mut self.1);
        source.try_for_each_triple(|q| {
            let res = q.pass_as_triple_ref(|q| writer.write_triple(q));
            SerializeError::map_result(res)
        })?;
        writer
            .finish()
            .map_err(|e| StreamError::SinkError(e.into()))?;
        Ok(self)
    }
}

impl<F> Stringifier for RdfXmlSerializerFactory<F, Vec<u8>>
where
    F: Fn() -> RdfXmlSerializer,
{
    fn as_utf8(&self) -> &[u8] {
        &self.1
    }
}

/// Error generated by Sophia serializers
#[derive(Error, Debug)]
pub enum SerializeError {
    #[error("IOError: {0}")]
    IO(#[from] std::io::Error),
    #[error("Unsupported generalized RDF")]
    Unsupported,
}

impl SerializeError {
    fn map_result<T>(res: Option<Result<T, std::io::Error>>) -> Result<T, Self> {
        match res {
            None => Err(SerializeError::Unsupported),
            Some(Err(io)) => Err(io.into()),
            Some(Ok(ok)) => Ok(ok),
        }
    }
}

#[cfg(test)]
mod test {
    use sophia_api::term::{IriRef, SimpleTerm, Term as SoTerm};

    use super::*;

    #[test]
    fn rdfxml() -> Result<(), Box<dyn std::error::Error>> {
        let v1 = make_graph();
        let txt = RdfXmlSerializerFactory(|| RdfXmlSerializer::new(), vec![])
            .serialize_graph(&v1)? // Sophia serializer API
            .to_string(); // Sophia stringifier API
        let v2: Vec<[SimpleTerm<'static>; 3]> = RdfXmlParserFactory(|| RdfXmlParser::new())
            .parse_str(&txt) // Sophia parser API
            .collect_triples()?;
        assert_eq!(v1, v2);
        Ok(())
    }

    fn make_graph() -> Vec<[SimpleTerm<'static>; 3]> {
        [[
            "https://example.org/s",
            "https://example.org/p",
            "https://example.org/o",
        ]]
        .into_iter()
        .map(|trpl| trpl.map(|txt| IriRef::new_unchecked(txt).into_term()))
        .collect()
    }
}
