#![allow(clippy::inherent_to_string, clippy::unused_self)]

use crate::format_err;
use crate::io::JsCanonicalizationAlgorithm;
use js_sys::{Array, Reflect, UriError, try_iter};
use oxigraph::model::dataset::Dataset;
use oxigraph::model::*;
use wasm_bindgen::prelude::*;

thread_local! {
    pub static FROM_JS: FromJsConverter = FromJsConverter::default();
}

// We skip_typescript on specific wasm_bindgen macros and provide custom TypeScript types for parts of this module in order to have narrower types
// instead of any and improve compatibility with RDF/JS Dataset interfaces (https://rdf.js.org/dataset-spec/).
// The latter expect e.g., termType to be a string literal and not the string type generated by wasm-bindgen.
#[wasm_bindgen(typescript_custom_section)]
const TYPESCRIPT_CUSTOM_SECTION: &str = r###"
/**
 * RDF/JS DataFactory-compatible methods
 */
export function namedNode(value: string): NamedNode;
export function blankNode(value?: string): BlankNode;
export function literal(value: string | undefined, languageOrDataType?: string | NamedNode | {language: string, direction?: "ltr" | "rtl"}): Literal;
export function defaultGraph(): DefaultGraph;
export function variable(value: string): Variable;
export function triple(subject: Triple_Subject, predicate: Triple_Predicate, object: Triple_Object): Triple;
export function quad(subject: Quad_Subject, predicate: Quad_Predicate, object: Quad_Object, graph?: Quad_Graph): Quad;


/**
 * Converts a plain JavaScript object representing an RDF/JS term to an Oxigraph term.
 * This enables interoperability with other RDF/JS libraries.
 *
 * @param original - A plain JavaScript object with {termType, value, ...} properties
 * @returns An Oxigraph term (NamedNode, BlankNode, Literal, Variable, DefaultGraph, Quad, or Triple)
 * @throws {Error} If the term type is not supported or the term is malformed
 *
 * @example
 * ```typescript
 * // Convert a plain object to an Oxigraph NamedNode
 * const term = fromTerm({ termType: "NamedNode", value: "http://example.com" });
 *
 * // Convert a literal from another RDF/JS library
 * const literal = fromTerm({
 *   termType: "Literal",
 *   value: "hello",
 *   language: "en",
 *   datatype: { termType: "NamedNode", value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" }
 * });
 * ```
 */
export function fromTerm(original: Term | null): Term | null;

/**
 * Converts a plain JavaScript object representing an RDF/JS quad to an Oxigraph Quad.
 * This enables interoperability with other RDF/JS libraries.
 *
 * @param original - A plain JavaScript object with {subject, predicate, object, graph} properties
 * @returns An Oxigraph Quad
 * @throws {Error} If the quad is malformed or contains invalid terms
 *
 * @example
 * ```typescript
 * // Convert a plain object to an Oxigraph Quad
 * const quad = fromQuad({
 *   subject: { termType: "NamedNode", value: "http://example.com/s" },
 *   predicate: { termType: "NamedNode", value: "http://example.com/p" },
 *   object: { termType: "Literal", value: "hello", datatype: { termType: "NamedNode", value: "http://www.w3.org/2001/XMLSchema#string" } },
 *   graph: { termType: "DefaultGraph", value: "" }
 * });
 *
 * // Convert a quad from another RDF/JS library
 * import { DataFactory } from '@rdfjs/data-model';
 * const rdfJsQuad = DataFactory.quad(...);
 * const oxigraphQuad = fromQuad(rdfJsQuad);
 * ```
 */
export function fromQuad(original: BaseQuad | null): Quad | null;
/**
 * RDF/JS-compatible BlankNode term
 */
export class BlankNode {
    readonly termType: "BlankNode";
    readonly value: string;

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "BlankNode"; value: string };
    clone(): BlankNode;
}

/**
 * RDF/JS-compatible DefaultGraph term
 */
export class DefaultGraph {
    readonly termType: "DefaultGraph";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "DefaultGraph"; value: "" };
    clone(): DefaultGraph;
}

/**
 * RDF/JS-compatible Literal term
 */
export class Literal {
    readonly datatype: NamedNode;
    readonly language: string;
    readonly direction: "ltr" | "rtl" | "";
    readonly termType: "Literal";
    readonly value: string;

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Literal"; value: string; datatype: { termType: "NamedNode"; value: string }; language: string; direction?: "ltr" | "rtl" | "" };
    clone(): Literal;
}

/**
 * RDF/JS-compatible NamedNode term
 */
export class NamedNode {
    readonly termType: "NamedNode";
    readonly value: string;

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "NamedNode"; value: string };
    clone(): NamedNode;
}

/**
 * BaseQuad is part of the RDF/JS spec and has no direct equivalent in Oxigraph.
 * 
 * It's copied here from the RDF/JS reference types (https://github.com/rdfjs/types , MIT license) because:
 *  - RDF/JS DatasetCore's match method takes Term parameters.
 *  - RDF/JS's Term is defined in terms of BaseQuad and not Quad.
 */ 
export interface BaseQuad {
    readonly graph: Term;
    readonly object: Term;
    readonly predicate: Term;
    readonly subject: Term;
    readonly termType: "Quad";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
}

/**
 * RDF/JS-compatible Quad term
 */
export class Quad implements BaseQuad {
    readonly graph: Quad_Graph;
    readonly object: Quad_Object;
    readonly predicate: Quad_Predicate;
    readonly subject: Quad_Subject;
    readonly termType: "Quad";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Quad"; value: ""; subject: any; predicate: any; object: any; graph: any };
    clone(): Quad;
}

/**
 * RDF-star Triple term (subject, predicate, object without graph)
 */
export class Triple {
    readonly object: Triple_Object;
    readonly predicate: Triple_Predicate;
    readonly subject: Triple_Subject;
    readonly termType: "Triple";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Triple"; value: ""; subject: any; predicate: any; object: any };
    clone(): Triple;
}

/**
 * Typedefs copied from the RDF/JS reference types (https://github.com/rdfjs/types)
 */
export type Quad_Graph = DefaultGraph | NamedNode | BlankNode | Variable;
export type Quad_Object = NamedNode | Literal | BlankNode | Quad | Triple | Variable;
export type Quad_Predicate = NamedNode | Variable;
export type Quad_Subject = NamedNode | BlankNode | Quad | Triple | Variable;

export type Triple_Object = NamedNode | Literal | BlankNode | Triple | Variable;
export type Triple_Predicate = NamedNode | Variable;
export type Triple_Subject = NamedNode | BlankNode | Triple | Variable;

/**
 * RDF/JS-compatible Term typedef. See note above re: BaseQuad.
 */
export type Term = NamedNode | BlankNode | Literal | Variable | DefaultGraph | BaseQuad | Triple;

/**
 * RDF/JS-compatible Variable term
 */
export class Variable {
    readonly termType: "Variable";
    readonly value: string;

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Variable"; value: string };
    clone(): Variable;
}

/**
 * An in-memory RDF dataset
 *
 * It can accommodate a fairly large number of quads (in the few millions).
 *
 * Warning: It interns the strings and does not do any garbage collection yet:
 * if you insert and remove a lot of different terms, memory will grow without any reduction.
 */
export class Dataset {
    readonly size: number;

    constructor(quads?: Iterable<Quad>);

    add(quad: Quad): void;

    delete(quad: Quad): boolean;

    discard(quad: Quad): void;

    has(quad: Quad): boolean;

    match(subject?: Term | null, predicate?: Term | null, object?: Term | null, graph?: Term | null): Quad[];

    clear(): void;

    quadsForSubject(subject: Quad_Subject): Quad[];

    quadsForPredicate(predicate: Quad_Predicate): Quad[];

    quadsForObject(object: Quad_Object): Quad[];

    quadsForGraphName(graph: Quad_Graph): Quad[];

    canonicalize(algorithm: CanonicalizationAlgorithm): void;

    toString(): string;
    clone(): Dataset;

    forEach(callback: (quad: Quad) => void): void;
    filter(callback: (quad: Quad) => boolean): Dataset;
    some(callback: (quad: Quad) => boolean): boolean;
    every(callback: (quad: Quad) => boolean): boolean;
    find(callback: (quad: Quad) => boolean): Quad | undefined;
    toArray(): Quad[];

    [Symbol.iterator](): Iterator<Quad>;
}
"###;

#[wasm_bindgen(js_name = namedNode)]
pub fn named_node(value: String) -> Result<JsNamedNode, JsValue> {
    NamedNode::new(value)
        .map(Into::into)
        .map_err(|v| UriError::new(&v.to_string()).into())
}

#[wasm_bindgen(js_name = blankNode)]
pub fn blank_node(value: Option<String>) -> Result<JsBlankNode, JsError> {
    Ok(if let Some(value) = value {
        BlankNode::new(value)?
    } else {
        BlankNode::default()
    }
    .into())
}

#[wasm_bindgen(skip_typescript)]
pub fn literal(
    value: Option<String>,
    language_or_datatype: &JsValue,
) -> Result<JsLiteral, JsValue> {
    if language_or_datatype.is_null() || language_or_datatype.is_undefined() {
        Ok(Literal::new_simple_literal(value.unwrap_or_default()).into())
    } else if language_or_datatype.is_string() {
        Ok(Literal::new_language_tagged_literal(
            value.unwrap_or_default(),
            language_or_datatype.as_string().unwrap_or_default(),
        )
        .map_err(JsError::from)?
        .into())
    } else {
        let language = Reflect::get(language_or_datatype, &JsValue::from_str("language"))?;
        if language.is_undefined() {
            if let JsTerm::NamedNode(datatype) =
                FROM_JS.with(|c| c.to_term(language_or_datatype))?
            {
                Ok(Literal::new_typed_literal(value.unwrap_or_default(), datatype).into())
            } else {
                Err(format_err!("The literal datatype should be a NamedNode"))
            }
        } else if let Some(direction) =
            Reflect::get(language_or_datatype, &JsValue::from_str("direction"))?.as_string()
        {
            #[cfg(feature = "rdf-12")]
            {
                Ok(Literal::new_directional_language_tagged_literal(
                    value.unwrap_or_default(),
                    language.as_string().unwrap_or_default(),
                    match direction.as_str() {
                        "ltr" => BaseDirection::Ltr,
                        "rtl" => BaseDirection::Rtl,
                        dir => return Err(format_err!("Invalid direction: {dir}")),
                    },
                )
                .map_err(JsError::from)?
                .into())
            }
            #[cfg(not(feature = "rdf-12"))]
            {
                Err(format_err!(
                    "RDF 1.2 is not enabled, {direction} direction is not supported"
                ))
            }
        } else {
            Ok(Literal::new_language_tagged_literal(
                value.unwrap_or_default(),
                language.as_string().unwrap_or_default(),
            )
            .map_err(JsError::from)?
            .into())
        }
    }
}

#[wasm_bindgen(js_name = defaultGraph)]
pub fn default_graph() -> JsDefaultGraph {
    JsDefaultGraph
}

#[wasm_bindgen(js_name = variable)]
pub fn variable(value: String) -> Result<JsVariable, JsError> {
    Ok(Variable::new(value)?.into())
}

#[wasm_bindgen(js_name = triple, skip_typescript)]
pub fn triple(
    subject: &JsValue,
    predicate: &JsValue,
    object: &JsValue,
) -> Result<JsTriple, JsValue> {
    Ok(FROM_JS
        .with(|c| c.to_triple_from_parts(subject, predicate, object))?
        .into())
}

#[wasm_bindgen(js_name = quad, skip_typescript)]
pub fn quad(
    subject: &JsValue,
    predicate: &JsValue,
    object: &JsValue,
    graph: &JsValue,
) -> Result<JsQuad, JsValue> {
    Ok(FROM_JS
        .with(|c| c.to_quad_from_parts(subject, predicate, object, graph))?
        .into())
}

#[wasm_bindgen(js_name = fromTerm)]
pub fn from_term(original: &JsValue) -> Result<JsValue, JsValue> {
    Ok(if original.is_null() {
        JsValue::NULL
    } else {
        FROM_JS.with(|c| c.to_term(original))?.into()
    })
}

#[wasm_bindgen(js_name = fromQuad)]
pub fn from_quad(original: &JsValue) -> Result<JsValue, JsValue> {
    Ok(if original.is_null() {
        JsValue::NULL
    } else {
        JsQuad::from(FROM_JS.with(|c| c.to_quad(original))?).into()
    })
}

#[wasm_bindgen(js_name = NamedNode, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsNamedNode {
    inner: NamedNode,
}

#[wasm_bindgen(js_class = NamedNode)]
impl JsNamedNode {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "NamedNode".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::NamedNode(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"NamedNode".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<NamedNode> for JsNamedNode {
    fn from(inner: NamedNode) -> Self {
        Self { inner }
    }
}

impl From<JsNamedNode> for NamedNode {
    fn from(node: JsNamedNode) -> Self {
        node.inner
    }
}

impl From<JsNamedNode> for NamedOrBlankNode {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

impl From<JsNamedNode> for Term {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

impl From<JsNamedNode> for GraphName {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = BlankNode, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsBlankNode {
    inner: BlankNode,
}

#[wasm_bindgen(js_class = BlankNode)]
impl JsBlankNode {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "BlankNode".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::BlankNode(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"BlankNode".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<BlankNode> for JsBlankNode {
    fn from(inner: BlankNode) -> Self {
        Self { inner }
    }
}

impl From<JsBlankNode> for BlankNode {
    fn from(node: JsBlankNode) -> Self {
        node.inner
    }
}

impl From<JsBlankNode> for NamedOrBlankNode {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

impl From<JsBlankNode> for Term {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

impl From<JsBlankNode> for GraphName {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = Literal, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsLiteral {
    inner: Literal,
}

#[wasm_bindgen(js_class = Literal)]
impl JsLiteral {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Literal".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.value().to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn language(&self) -> String {
        self.inner.language().unwrap_or("").to_owned()
    }

    #[cfg(feature = "rdf-12")]
    #[wasm_bindgen(getter)]
    pub fn direction(&self) -> String {
        self.inner
            .direction()
            .map_or_else(String::new, |d| d.to_string())
    }

    #[wasm_bindgen(getter)]
    pub fn datatype(&self) -> JsNamedNode {
        self.inner.datatype().into_owned().into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Literal(other))) = FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.value().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Literal".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.value().into()).unwrap();
        Reflect::set(&obj, &"datatype".into(), &self.datatype().to_json()).unwrap();
        if let Some(language) = self.inner.language() {
            Reflect::set(&obj, &"language".into(), &language.into()).unwrap();
        } else {
            Reflect::set(&obj, &"language".into(), &"".into()).unwrap();
        }
        #[cfg(feature = "rdf-12")]
        if let Some(direction) = self.inner.direction() {
            Reflect::set(&obj, &"direction".into(), &direction.to_string().into()).unwrap();
        } else {
            Reflect::set(&obj, &"direction".into(), &"".into()).unwrap();
        }
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Literal> for JsLiteral {
    fn from(inner: Literal) -> Self {
        Self { inner }
    }
}

impl From<JsLiteral> for Literal {
    fn from(node: JsLiteral) -> Self {
        node.inner
    }
}

impl From<JsLiteral> for Term {
    fn from(node: JsLiteral) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = DefaultGraph, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]
pub struct JsDefaultGraph;

#[wasm_bindgen(js_class = DefaultGraph)]
impl JsDefaultGraph {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "DefaultGraph".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        "DEFAULT".to_owned()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::DefaultGraph(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"DefaultGraph".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        *self
    }
}

#[wasm_bindgen(js_name = Variable, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsVariable {
    inner: Variable,
}

#[wasm_bindgen(js_class = Variable)]
impl JsVariable {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Variable".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Variable(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Variable".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Variable> for JsVariable {
    fn from(inner: Variable) -> Self {
        Self { inner }
    }
}

impl From<JsVariable> for Variable {
    fn from(node: JsVariable) -> Self {
        node.inner
    }
}

#[wasm_bindgen(js_name = Triple, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsTriple {
    inner: Triple,
}

#[wasm_bindgen(js_class = Triple)]
impl JsTriple {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Triple".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(getter = subject)]
    pub fn subject(&self) -> JsValue {
        JsTerm::from(self.inner.subject.clone()).into()
    }

    #[wasm_bindgen(getter = predicate)]
    pub fn predicate(&self) -> JsValue {
        JsTerm::from(self.inner.predicate.clone()).into()
    }

    #[wasm_bindgen(getter = object)]
    pub fn object(&self) -> JsValue {
        JsTerm::from(self.inner.object.clone()).into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Triple(other))) = FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Triple".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();

        // Convert subject, predicate, object to JSON
        match JsTerm::from(self.inner.subject.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"subject".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"subject".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"subject".into(), &t.to_json()).unwrap();
            }
            _ => {}
        }

        if let JsTerm::NamedNode(nn) = JsTerm::from(self.inner.predicate.clone()) {
            Reflect::set(&obj, &"predicate".into(), &nn.to_json()).unwrap();
        }

        match JsTerm::from(self.inner.object.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"object".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"object".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Literal(lit) => {
                Reflect::set(&obj, &"object".into(), &lit.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"object".into(), &t.to_json()).unwrap();
            }
            _ => {}
        }

        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Triple> for JsTriple {
    fn from(inner: Triple) -> Self {
        Self { inner }
    }
}

impl From<JsTriple> for Triple {
    fn from(triple: JsTriple) -> Self {
        triple.inner
    }
}

impl From<JsTriple> for Term {
    fn from(triple: JsTriple) -> Self {
        triple.inner.into()
    }
}

#[wasm_bindgen(js_name = Quad, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsQuad {
    inner: Quad,
}

#[wasm_bindgen(js_class = Quad)]
impl JsQuad {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Quad".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(getter = subject)]
    pub fn subject(&self) -> JsValue {
        JsTerm::from(self.inner.subject.clone()).into()
    }

    #[wasm_bindgen(getter = predicate)]
    pub fn predicate(&self) -> JsValue {
        JsTerm::from(self.inner.predicate.clone()).into()
    }

    #[wasm_bindgen(getter = object)]
    pub fn object(&self) -> JsValue {
        JsTerm::from(self.inner.object.clone()).into()
    }

    #[wasm_bindgen(getter = graph)]
    pub fn graph(&self) -> JsValue {
        JsTerm::from(self.inner.graph_name.clone()).into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Quad(other))) = FromJsConverter::default().to_optional_term(other) {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Quad".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();

        // Convert subject, predicate, object, graph to JSON
        match JsTerm::from(self.inner.subject.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"subject".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"subject".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"subject".into(), &t.to_json()).unwrap();
            }
            JsTerm::Quad(q) => {
                Reflect::set(&obj, &"subject".into(), &q.to_json()).unwrap();
            }
            _ => {}
        }

        if let JsTerm::NamedNode(nn) = JsTerm::from(self.inner.predicate.clone()) {
            Reflect::set(&obj, &"predicate".into(), &nn.to_json()).unwrap();
        }

        match JsTerm::from(self.inner.object.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"object".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"object".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Literal(lit) => {
                Reflect::set(&obj, &"object".into(), &lit.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"object".into(), &t.to_json()).unwrap();
            }
            JsTerm::Quad(q) => {
                Reflect::set(&obj, &"object".into(), &q.to_json()).unwrap();
            }
            _ => {}
        }

        match JsTerm::from(self.inner.graph_name.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"graph".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"graph".into(), &bn.to_json()).unwrap();
            }
            JsTerm::DefaultGraph(dg) => {
                Reflect::set(&obj, &"graph".into(), &dg.to_json()).unwrap();
            }
            _ => {}
        }

        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Triple> for JsQuad {
    fn from(inner: Triple) -> Self {
        Self {
            inner: inner.in_graph(GraphName::DefaultGraph),
        }
    }
}

impl From<Quad> for JsQuad {
    fn from(inner: Quad) -> Self {
        Self { inner }
    }
}

impl From<JsQuad> for Quad {
    fn from(quad: JsQuad) -> Self {
        quad.inner
    }
}

impl From<JsQuad> for Triple {
    fn from(quad: JsQuad) -> Self {
        quad.inner.into()
    }
}

#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub enum JsTerm {
    NamedNode(JsNamedNode),
    BlankNode(JsBlankNode),
    Literal(JsLiteral),
    DefaultGraph(JsDefaultGraph),
    Variable(JsVariable),
    Triple(JsTriple),
    Quad(JsQuad),
}

impl From<JsTerm> for JsValue {
    fn from(value: JsTerm) -> Self {
        match value {
            JsTerm::NamedNode(v) => v.into(),
            JsTerm::BlankNode(v) => v.into(),
            JsTerm::Literal(v) => v.into(),
            JsTerm::DefaultGraph(v) => v.into(),
            JsTerm::Variable(v) => v.into(),
            JsTerm::Triple(v) => v.into(),
            JsTerm::Quad(v) => v.into(),
        }
    }
}

impl From<NamedNode> for JsTerm {
    fn from(node: NamedNode) -> Self {
        Self::NamedNode(node.into())
    }
}

impl From<BlankNode> for JsTerm {
    fn from(node: BlankNode) -> Self {
        Self::BlankNode(node.into())
    }
}

impl From<Literal> for JsTerm {
    fn from(literal: Literal) -> Self {
        Self::Literal(literal.into())
    }
}

impl From<NamedOrBlankNode> for JsTerm {
    fn from(node: NamedOrBlankNode) -> Self {
        match node {
            NamedOrBlankNode::NamedNode(node) => node.into(),
            NamedOrBlankNode::BlankNode(node) => node.into(),
        }
    }
}

impl From<Term> for JsTerm {
    fn from(term: Term) -> Self {
        match term {
            Term::NamedNode(node) => node.into(),
            Term::BlankNode(node) => node.into(),
            Term::Literal(literal) => literal.into(),
            #[cfg(feature = "rdf-12")]
            Term::Triple(node) => node.into(),
        }
    }
}

impl From<GraphName> for JsTerm {
    fn from(name: GraphName) -> Self {
        match name {
            GraphName::NamedNode(node) => node.into(),
            GraphName::BlankNode(node) => node.into(),
            GraphName::DefaultGraph => Self::DefaultGraph(JsDefaultGraph),
        }
    }
}

impl From<Variable> for JsTerm {
    fn from(variable: Variable) -> Self {
        Self::Variable(variable.into())
    }
}

impl From<Triple> for JsTerm {
    fn from(triple: Triple) -> Self {
        Self::Triple(triple.into())
    }
}

impl From<Box<Triple>> for JsTerm {
    fn from(triple: Box<Triple>) -> Self {
        Self::Triple(triple.as_ref().clone().into())
    }
}

impl From<Quad> for JsTerm {
    fn from(quad: Quad) -> Self {
        Self::Quad(quad.into())
    }
}

impl TryFrom<JsTerm> for NamedNode {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Err(format_err!(
                "The blank node {} is not a named node",
                node.inner
            )),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a named node",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Err(format_err!("The default graph is not a named node")),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a named node",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a named node",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!("The quad {} is not a named node", quad.inner)),
        }
    }
}

impl TryFrom<JsTerm> for NamedOrBlankNode {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a possible named or blank node term",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Err(format_err!(
                "The default graph is not a possible named or blank node term"
            )),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible named or blank node term",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible named or blank node term",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible named or blank node term",
                quad.inner
            )),
        }
    }
}

impl TryFrom<JsTerm> for Term {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Ok(literal.into()),
            JsTerm::DefaultGraph(_) => {
                Err(format_err!("The default graph is not a possible RDF term"))
            }
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible RDF term",
                variable.inner
            )),
            #[cfg(feature = "rdf-12")]
            JsTerm::Triple(triple) => Ok(triple.into()),
            #[cfg(not(feature = "rdf-12"))]
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible RDF term",
                triple.inner
            )),
            #[cfg(feature = "rdf-12")]
            JsTerm::Quad(quad) => Ok(Triple::from(quad).into()),
            #[cfg(not(feature = "rdf-12"))]
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible RDF term",
                quad.inner
            )),
        }
    }
}

impl TryFrom<JsTerm> for GraphName {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a possible graph name",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Ok(Self::DefaultGraph),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible RDF term",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible RDF term",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible RDF term",
                quad.inner
            )),
        }
    }
}

pub struct FromJsConverter {
    term_type: JsValue,
    value: JsValue,
    language: JsValue,
    #[cfg(feature = "rdf-12")]
    direction: JsValue,
    datatype: JsValue,
    subject: JsValue,
    predicate: JsValue,
    object: JsValue,
    graph: JsValue,
}

impl Default for FromJsConverter {
    fn default() -> Self {
        Self {
            term_type: JsValue::from_str("termType"),
            value: JsValue::from_str("value"),
            language: JsValue::from_str("language"),
            #[cfg(feature = "rdf-12")]
            direction: JsValue::from_str("direction"),
            datatype: JsValue::from_str("datatype"),
            subject: JsValue::from_str("subject"),
            predicate: JsValue::from_str("predicate"),
            object: JsValue::from_str("object"),
            graph: JsValue::from_str("graph"),
        }
    }
}

impl FromJsConverter {
    pub fn to_term(&self, value: &JsValue) -> Result<JsTerm, JsValue> {
        let term_type = Reflect::get(value, &self.term_type)?;
        if let Some(term_type) = term_type.as_string() {
            match term_type.as_str() {
                "NamedNode" => Ok(NamedNode::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("NamedNode should have a string value"))?,
                )
                .map_err(|v| UriError::new(&v.to_string()))?
                .into()),
                "BlankNode" => Ok(BlankNode::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("BlankNode should have a string value"))?,
                )
                .map_err(JsError::from)?
                .into()),
                "Literal" => {
                    if let JsTerm::NamedNode(datatype) =
                        self.to_term(&Reflect::get(value, &self.datatype)?)?
                    {
                        let datatype = NamedNode::from(datatype);
                        let literal_value = Reflect::get(value, &self.value)?
                            .as_string()
                            .ok_or_else(|| format_err!("Literal should have a string value"))?;
                        Ok(match datatype.as_str() {
                                    "http://www.w3.org/2001/XMLSchema#string" => Literal::new_simple_literal(literal_value),
                                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" => Literal::new_language_tagged_literal(literal_value, Reflect::get(value, &self.language)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:langString datatype should have a language"),
                                    )?).map_err(JsError::from)?,
                                    #[cfg(feature = "rdf-12")]
                                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString" => Literal::new_directional_language_tagged_literal(literal_value, Reflect::get(value, &self.language)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:dirLangString datatype should have a language"),
                                    )?, match Reflect::get(value, &self.direction)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:dirLangString datatype should have a direction"),
                                    )?.as_str() {
                                        "ltr" => BaseDirection::Ltr,
                                        "rtl" => BaseDirection::Rtl,
                                        dir => return Err(format_err!("Invalid direction: {dir}")),
                                    }).map_err(JsError::from)?,
                                    _ => Literal::new_typed_literal(literal_value, datatype)
                                }.into())
                    } else {
                        Err(format_err!(
                            "Literal should have a datatype that is a NamedNode"
                        ))
                    }
                }
                "DefaultGraph" => Ok(JsTerm::DefaultGraph(JsDefaultGraph)),
                "Variable" => Ok(Variable::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("Variable should have a string value"))?,
                )
                .map_err(JsError::from)?
                .into()),
                "Triple" => Ok(self.to_triple(value)?.into()),
                "Quad" => Ok(self.to_quad(value)?.into()),
                _ => Err(format_err!(
                    "The termType {term_type} is not supported by Oxigraph"
                )),
            }
        } else if term_type.is_undefined() {
            // It's a quad without the proper type
            if Reflect::has(value, &self.subject)?
                && Reflect::has(value, &self.predicate)?
                && Reflect::has(value, &self.object)?
            {
                Ok(self.to_quad(value)?.into())
            } else {
                Err(format_err!(
                    "RDF term objects should have a termType attribute"
                ))
            }
        } else {
            Err(format_err!("The object termType field should be a string"))
        }
    }

    pub fn to_optional_term(&self, value: &JsValue) -> Result<Option<JsTerm>, JsValue> {
        if value.is_null() || value.is_undefined() {
            Ok(None)
        } else {
            self.to_term(value).map(Some)
        }
    }

    pub fn to_quad(&self, value: &JsValue) -> Result<Quad, JsValue> {
        self.to_quad_from_parts(
            &Reflect::get(value, &self.subject)?,
            &Reflect::get(value, &self.predicate)?,
            &Reflect::get(value, &self.object)?,
            &Reflect::get(value, &self.graph)?,
        )
    }

    pub fn to_quad_from_parts(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
        graph_name: &JsValue,
    ) -> Result<Quad, JsValue> {
        Ok(Quad {
            subject: NamedOrBlankNode::try_from(self.to_term(subject)?)?,
            predicate: NamedNode::try_from(self.to_term(predicate)?)?,
            object: Term::try_from(self.to_term(object)?)?,
            graph_name: if graph_name.is_undefined() {
                GraphName::DefaultGraph
            } else {
                GraphName::try_from(self.to_term(graph_name)?)?
            },
        })
    }

    pub fn to_triple(&self, value: &JsValue) -> Result<Triple, JsValue> {
        self.to_triple_from_parts(
            &Reflect::get(value, &self.subject)?,
            &Reflect::get(value, &self.predicate)?,
            &Reflect::get(value, &self.object)?,
        )
    }

    pub fn to_triple_from_parts(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
    ) -> Result<Triple, JsValue> {
        Ok(Triple {
            subject: NamedOrBlankNode::try_from(self.to_term(subject)?)?,
            predicate: NamedNode::try_from(self.to_term(predicate)?)?,
            object: Term::try_from(self.to_term(object)?)?,
        })
    }
}

#[wasm_bindgen(js_name = Dataset, skip_typescript)]
pub struct JsDataset {
    inner: Dataset,
}

#[wasm_bindgen(js_class = Dataset)]
impl JsDataset {
    #[wasm_bindgen(constructor)]
    pub fn new(quads: &JsValue) -> Result<JsDataset, JsValue> {
        let mut inner = Dataset::new();
        if !quads.is_undefined() && !quads.is_null() {
            if let Some(quads) = try_iter(quads)? {
                for quad in quads {
                    inner.insert(&FROM_JS.with(|c| c.to_quad(&quad?))?);
                }
            }
        }
        Ok(Self { inner })
    }

    pub fn add(&mut self, quad: &JsValue) -> Result<(), JsValue> {
        self.inner.insert(&FROM_JS.with(|c| c.to_quad(quad))?);
        Ok(())
    }

    pub fn delete(&mut self, quad: &JsValue) -> Result<bool, JsValue> {
        Ok(self.inner.remove(&FROM_JS.with(|c| c.to_quad(quad))?))
    }

    pub fn discard(&mut self, quad: &JsValue) -> Result<(), JsValue> {
        self.inner.remove(&FROM_JS.with(|c| c.to_quad(quad))?);
        Ok(())
    }

    pub fn has(&self, quad: &JsValue) -> Result<bool, JsValue> {
        Ok(self.inner.contains(&FROM_JS.with(|c| c.to_quad(quad))?))
    }

    #[wasm_bindgen(getter = size)]
    pub fn size(&self) -> usize {
        self.inner.len()
    }

    #[wasm_bindgen(js_name = match)]
    pub fn match_quads(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
        graph_name: &JsValue,
    ) -> Result<Box<[JsValue]>, JsValue> {
        let subject = if let Some(subject) = FROM_JS.with(|c| c.to_optional_term(subject))? {
            Some(NamedOrBlankNode::try_from(subject)?)
        } else {
            None
        };
        let predicate = if let Some(predicate) = FROM_JS.with(|c| c.to_optional_term(predicate))? {
            Some(NamedNode::try_from(predicate)?)
        } else {
            None
        };
        let object = if let Some(object) = FROM_JS.with(|c| c.to_optional_term(object))? {
            Some(Term::try_from(object)?)
        } else {
            None
        };
        let graph_name =
            if let Some(graph_name) = FROM_JS.with(|c| c.to_optional_term(graph_name))? {
                Some(GraphName::try_from(graph_name)?)
            } else {
                None
            };

        let quads: Vec<JsValue> = self
            .inner
            .iter()
            .filter(|quad| {
                (subject.is_none() || subject.as_ref().map(|s| s.as_ref()) == Some(quad.subject))
                    && (predicate.is_none() || predicate.as_ref().map(|p| p.as_ref()) == Some(quad.predicate))
                    && (object.is_none() || object.as_ref().map(|o| o.as_ref()) == Some(quad.object))
                    && (graph_name.is_none() || graph_name.as_ref().map(|g| g.as_ref()) == Some(quad.graph_name))
            })
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect();

        Ok(quads.into_boxed_slice())
    }

    pub fn clear(&mut self) {
        self.inner.clear();
    }

    #[wasm_bindgen(js_name = quadsForSubject)]
    pub fn quads_for_subject(&self, subject: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let subject = FROM_JS.with(|c| c.to_term(subject))?;
        let subject = NamedOrBlankNode::try_from(subject)?;
        Ok(self
            .inner
            .quads_for_subject(&subject)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForPredicate)]
    pub fn quads_for_predicate(&self, predicate: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let predicate = FROM_JS.with(|c| c.to_term(predicate))?;
        let predicate = NamedNode::try_from(predicate)?;
        Ok(self
            .inner
            .quads_for_predicate(&predicate)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForObject)]
    pub fn quads_for_object(&self, object: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let object = FROM_JS.with(|c| c.to_term(object))?;
        let object = Term::try_from(object)?;
        Ok(self
            .inner
            .quads_for_object(&object)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForGraphName)]
    pub fn quads_for_graph_name(&self, graph_name: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let graph_name = FROM_JS.with(|c| c.to_term(graph_name))?;
        let graph_name = GraphName::try_from(graph_name)?;
        Ok(self
            .inner
            .quads_for_graph_name(&graph_name)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    pub fn canonicalize(&mut self, algorithm: &JsCanonicalizationAlgorithm) {
        self.inner.canonicalize((*algorithm).into());
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    // Symbol.iterator implementation - must be manually wired up in JavaScript
    // as wasm-bindgen doesn't support computed property names
    #[wasm_bindgen(skip_typescript)]
    pub fn __iterator(&self) -> JsValue {
        let quads: Vec<JsValue> = self
            .inner
            .iter()
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect();
        Array::from_iter(quads).values().into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }

    // Collection methods for JavaScript compatibility
    #[wasm_bindgen(js_name = forEach)]
    pub fn for_each(&self, callback: &js_sys::Function) -> Result<(), JsValue> {
        let this = JsValue::NULL;
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            callback.call1(&this, &quad_js)?;
        }
        Ok(())
    }

    #[wasm_bindgen]
    pub fn filter(&self, callback: &js_sys::Function) -> Result<JsDataset, JsValue> {
        let this = JsValue::NULL;
        let mut filtered = Dataset::new();
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.clone().into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                filtered.insert(&quad.into_owned());
            }
        }
        Ok(Self { inner: filtered })
    }

    #[wasm_bindgen]
    pub fn some(&self, callback: &js_sys::Function) -> Result<bool, JsValue> {
        let this = JsValue::NULL;
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(true);
            }
        }
        Ok(false)
    }

    #[wasm_bindgen]
    pub fn every(&self, callback: &js_sys::Function) -> Result<bool, JsValue> {
        let this = JsValue::NULL;
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if !callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(false);
            }
        }
        Ok(true)
    }

    #[wasm_bindgen]
    pub fn find(&self, callback: &js_sys::Function) -> Result<JsValue, JsValue> {
        let this = JsValue::NULL;
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(quad_js);
            }
        }
        Ok(JsValue::UNDEFINED)
    }

    #[wasm_bindgen(js_name = toArray)]
    pub fn to_array(&self) -> Box<[JsValue]> {
        self.inner
            .iter()
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice()
    }
}
