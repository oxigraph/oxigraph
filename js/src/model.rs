#![allow(clippy::inherent_to_string, clippy::unused_self)]

use crate::format_err;
use crate::io::JsCanonicalizationAlgorithm;
use js_sys::{Array, Reflect, UriError, try_iter};
use oxigraph::model::dataset::Dataset;
use oxigraph::model::*;
use wasm_bindgen::prelude::*;

thread_local! {
    pub static FROM_JS: FromJsConverter = FromJsConverter::default();
}

// We skip_typescript on specific wasm_bindgen macros and provide custom TypeScript types for parts of this module in order to have narrower types
// instead of any and improve compatibility with RDF/JS Dataset interfaces (https://rdf.js.org/dataset-spec/).
// The latter expect e.g., termType to be a string literal and not the string type generated by wasm-bindgen.
#[wasm_bindgen(typescript_custom_section)]
const TYPESCRIPT_CUSTOM_SECTION: &str = r###"
/**
 * RDF/JS DataFactory-compatible methods for creating RDF terms.
 *
 * @see {@link https://rdf.js.org/data-model-spec/#datafactory-interface | RDF/JS DataFactory}
 */

/**
 * Creates a NamedNode (IRI reference).
 *
 * @param value - The IRI string
 * @returns A new NamedNode
 * @throws {URIError} If the IRI is invalid
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-IRIs | RDF 1.1 IRIs}
 *
 * @example
 * ```typescript
 * const person = namedNode('http://example.com/alice');
 * const foafName = namedNode('http://xmlns.com/foaf/0.1/name');
 * ```
 */
export function namedNode(value: string): NamedNode;

/**
 * Creates a BlankNode (anonymous node).
 *
 * @param value - Optional blank node identifier. If not provided, a unique ID is generated
 * @returns A new BlankNode
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes | RDF 1.1 Blank Nodes}
 *
 * @example
 * ```typescript
 * // Auto-generated ID
 * const bn1 = blankNode(); // e.g., _:b0
 *
 * // Custom ID
 * const bn2 = blankNode('person1'); // _:person1
 * ```
 */
export function blankNode(value?: string): BlankNode;

/**
 * Creates a Literal (value with optional language tag or datatype).
 *
 * @param value - The lexical form of the literal
 * @param languageOrDataType - Either:
 *   - A language tag string (e.g., 'en', 'fr')
 *   - A NamedNode for the datatype (e.g., xsd:integer)
 *   - An object with language and optional direction (RDF 1.2)
 * @returns A new Literal
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal | RDF 1.1 Literals}
 *
 * @example
 * ```typescript
 * // Simple string literal (xsd:string)
 * const name = literal('Alice');
 *
 * // Language-tagged literal
 * const greeting = literal('Hello', 'en');
 *
 * // Typed literal
 * const age = literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'));
 *
 * // Directional language-tagged literal (RDF 1.2)
 * const rtl = literal('مرحبا', { language: 'ar', direction: 'rtl' });
 * ```
 */
export function literal(value: string | undefined, languageOrDataType?: string | NamedNode | {language: string, direction?: "ltr" | "rtl"}): Literal;

/**
 * Creates the DefaultGraph term.
 * Used to represent the default (unnamed) graph in a dataset.
 *
 * @returns The DefaultGraph singleton
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-dataset | RDF 1.1 Datasets}
 *
 * @example
 * ```typescript
 * const q = quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/name'),
 *   literal('Alice'),
 *   defaultGraph() // Explicitly specify default graph
 * );
 * ```
 */
export function defaultGraph(): DefaultGraph;

/**
 * Creates a Variable (used in SPARQL queries).
 *
 * @param value - The variable name (without the '?' or '$' prefix)
 * @returns A new Variable
 *
 * @example
 * ```typescript
 * const subjectVar = variable('s');
 * const predicateVar = variable('p');
 * const objectVar = variable('o');
 * ```
 */
export function variable(value: string): Variable;

/**
 * Creates a Triple (RDF-star nested triple without graph).
 *
 * @param subject - The subject of the triple
 * @param predicate - The predicate of the triple
 * @param object - The object of the triple
 * @returns A new Triple
 *
 * @see {@link https://www.w3.org/TR/rdf12-concepts/#section-triples | RDF 1.2 Triples (RDF-star)}
 *
 * @example
 * ```typescript
 * // Create a nested triple
 * const innerTriple = triple(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/knows'),
 *   namedNode('http://example.com/bob')
 * );
 *
 * // Use it as a subject in another triple (quoted triple pattern)
 * const metaTriple = quad(
 *   innerTriple,
 *   namedNode('http://example.com/certainty'),
 *   literal('0.9', namedNode('http://www.w3.org/2001/XMLSchema#decimal'))
 * );
 * ```
 */
export function triple(subject: Triple_Subject, predicate: Triple_Predicate, object: Triple_Object): Triple;

/**
 * Creates a Quad (RDF statement with optional graph name).
 *
 * @param subject - The subject of the quad
 * @param predicate - The predicate of the quad
 * @param object - The object of the quad
 * @param graph - Optional graph name (defaults to DefaultGraph)
 * @returns A new Quad
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-triples | RDF 1.1 Triples}
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-dataset | RDF 1.1 Datasets}
 *
 * @example
 * ```typescript
 * // Triple in default graph
 * const triple = quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/name'),
 *   literal('Alice')
 * );
 *
 * // Quad in named graph
 * const quadInGraph = quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/knows'),
 *   namedNode('http://example.com/bob'),
 *   namedNode('http://example.com/socialGraph')
 * );
 * ```
 */
export function quad(subject: Quad_Subject, predicate: Quad_Predicate, object: Quad_Object, graph?: Quad_Graph): Quad;


/**
 * Converts a plain JavaScript object representing an RDF/JS term to an Oxigraph term.
 * This enables interoperability with other RDF/JS libraries.
 *
 * @param original - A plain JavaScript object with {termType, value, ...} properties
 * @returns An Oxigraph term (NamedNode, BlankNode, Literal, Variable, DefaultGraph, Quad, or Triple)
 * @throws {Error} If the term type is not supported or the term is malformed
 *
 * @example
 * ```typescript
 * // Convert a plain object to an Oxigraph NamedNode
 * const term = fromTerm({ termType: "NamedNode", value: "http://example.com" });
 *
 * // Convert a literal from another RDF/JS library
 * const literal = fromTerm({
 *   termType: "Literal",
 *   value: "hello",
 *   language: "en",
 *   datatype: { termType: "NamedNode", value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" }
 * });
 * ```
 */
export function fromTerm(original: Term | null): Term | null;

/**
 * Converts a plain JavaScript object representing an RDF/JS quad to an Oxigraph Quad.
 * This enables interoperability with other RDF/JS libraries.
 *
 * @param original - A plain JavaScript object with {subject, predicate, object, graph} properties
 * @returns An Oxigraph Quad
 * @throws {Error} If the quad is malformed or contains invalid terms
 *
 * @example
 * ```typescript
 * // Convert a plain object to an Oxigraph Quad
 * const quad = fromQuad({
 *   subject: { termType: "NamedNode", value: "http://example.com/s" },
 *   predicate: { termType: "NamedNode", value: "http://example.com/p" },
 *   object: { termType: "Literal", value: "hello", datatype: { termType: "NamedNode", value: "http://www.w3.org/2001/XMLSchema#string" } },
 *   graph: { termType: "DefaultGraph", value: "" }
 * });
 *
 * // Convert a quad from another RDF/JS library
 * import { DataFactory } from '@rdfjs/data-model';
 * const rdfJsQuad = DataFactory.quad(...);
 * const oxigraphQuad = fromQuad(rdfJsQuad);
 * ```
 */
export function fromQuad(original: BaseQuad | null): Quad | null;
/**
 * RDF/JS-compatible BlankNode term.
 *
 * Blank nodes are used to express data that doesn't have a global identifier.
 * They act as local identifiers within an RDF graph.
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes | RDF 1.1 Blank Nodes}
 * @see {@link https://rdf.js.org/data-model-spec/#blanknode-interface | RDF/JS BlankNode}
 *
 * @example
 * ```typescript
 * // Create a blank node with auto-generated ID
 * const bn = blankNode();
 * console.log(bn.value); // e.g., "b0"
 *
 * // Create a blank node with specific ID
 * const bn2 = blankNode('person1');
 * console.log(bn2.value); // "person1"
 *
 * // Use in a quad
 * store.add(quad(
 *   bn,
 *   namedNode('http://xmlns.com/foaf/0.1/name'),
 *   literal('Anonymous Person')
 * ));
 * ```
 */
export class BlankNode {
    /** Always "BlankNode" for blank node terms */
    readonly termType: "BlankNode";

    /** The blank node identifier (label) */
    readonly value: string;

    /**
     * Checks if this blank node equals another term.
     * Blank nodes are only equal if they have the same identifier.
     *
     * @param other - The term to compare with
     * @returns true if the terms are equal
     *
     * @example
     * ```typescript
     * const bn1 = blankNode('x');
     * const bn2 = blankNode('x');
     * const bn3 = blankNode('y');
     * console.log(bn1.equals(bn2)); // true
     * console.log(bn1.equals(bn3)); // false
     * ```
     */
    equals(other: Term | null | undefined): boolean;

    /**
     * Returns a string representation of the blank node.
     * Format: "_:identifier"
     *
     * @returns String representation
     *
     * @example
     * ```typescript
     * const bn = blankNode('person1');
     * console.log(bn.toString()); // "_:person1"
     * ```
     */
    toString(): string;

    /**
     * Returns the blank node identifier.
     * Alias for the value property.
     *
     * @returns The identifier
     */
    valueOf(): string;

    /**
     * Returns a JSON representation of the blank node.
     * Useful for serialization.
     *
     * @returns JSON object with termType and value
     *
     * @example
     * ```typescript
     * const bn = blankNode('x');
     * console.log(JSON.stringify(bn));
     * // {"termType":"BlankNode","value":"x"}
     * ```
     */
    toJSON(): { termType: "BlankNode"; value: string };

    /**
     * Creates a shallow copy of the blank node.
     *
     * @returns A new BlankNode with the same identifier
     */
    clone(): BlankNode;
}

/**
 * RDF/JS-compatible DefaultGraph term
 */
export class DefaultGraph {
    readonly termType: "DefaultGraph";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "DefaultGraph"; value: "" };
    clone(): DefaultGraph;
}

/**
 * RDF/JS-compatible Literal term.
 *
 * Literals represent values such as strings, numbers, and dates in RDF.
 * They have a lexical form (the string value), a datatype, and optionally a language tag.
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-Graph-Literal | RDF 1.1 Literals}
 * @see {@link https://rdf.js.org/data-model-spec/#literal-interface | RDF/JS Literal}
 *
 * @example
 * ```typescript
 * // Simple string literal
 * const name = literal('Alice');
 *
 * // Language-tagged string
 * const greeting = literal('Hello', 'en');
 * const bonjour = literal('Bonjour', 'fr');
 *
 * // Typed literal (number)
 * const age = literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'));
 *
 * // With directional language tag (RDF 1.2)
 * const rtlText = literal('مرحبا', { language: 'ar', direction: 'rtl' });
 *
 * // Use in a quad
 * store.add(quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/name'),
 *   name
 * ));
 * ```
 */
export class Literal {
    /**
     * The datatype of the literal as a NamedNode.
     * For plain literals, this is xsd:string.
     * For language-tagged literals, this is rdf:langString.
     * @readonly
     */
    readonly datatype: NamedNode;

    /**
     * The language tag (e.g., 'en', 'fr', 'de').
     * Empty string if not a language-tagged literal.
     * @readonly
     */
    readonly language: string;

    /**
     * The text direction ('ltr', 'rtl', or '').
     * Only available with RDF 1.2 feature enabled.
     * @readonly
     */
    readonly direction: "ltr" | "rtl" | "";

    /** Always "Literal" for literal terms */
    readonly termType: "Literal";

    /** The lexical form (string representation) of the literal */
    readonly value: string;

    /**
     * Checks if this literal equals another term.
     * Literals are equal if they have the same value, language, direction, and datatype.
     *
     * @param other - The term to compare with
     * @returns true if the terms are equal
     *
     * @example
     * ```typescript
     * const lit1 = literal('hello', 'en');
     * const lit2 = literal('hello', 'en');
     * const lit3 = literal('hello', 'fr');
     * const lit4 = literal('hello'); // Different datatype
     *
     * console.log(lit1.equals(lit2)); // true
     * console.log(lit1.equals(lit3)); // false (different language)
     * console.log(lit1.equals(lit4)); // false (different datatype)
     * ```
     */
    equals(other: Term | null | undefined): boolean;

    /**
     * Returns a string representation of the literal.
     * Format varies based on the literal type:
     * - Simple: "value"
     * - Language-tagged: "value"@lang
     * - Typed: "value"^^<datatype>
     *
     * @returns String representation
     *
     * @example
     * ```typescript
     * console.log(literal('Alice').toString()); // "Alice"
     * console.log(literal('Hello', 'en').toString()); // "Hello"@en
     * console.log(literal('42', namedNode('http://www.w3.org/2001/XMLSchema#integer')).toString());
     * // "42"^^<http://www.w3.org/2001/XMLSchema#integer>
     * ```
     */
    toString(): string;

    /**
     * Returns the lexical form of the literal.
     * Alias for the value property.
     *
     * @returns The string value
     */
    valueOf(): string;

    /**
     * Returns a JSON representation of the literal.
     * Useful for serialization.
     *
     * @returns JSON object with termType, value, datatype, language, and optionally direction
     *
     * @example
     * ```typescript
     * const lit = literal('Hello', 'en');
     * console.log(JSON.stringify(lit));
     * // {"termType":"Literal","value":"Hello","datatype":{...},"language":"en"}
     * ```
     */
    toJSON(): { termType: "Literal"; value: string; datatype: { termType: "NamedNode"; value: string }; language: string; direction?: "ltr" | "rtl" | "" };

    /**
     * Creates a shallow copy of the literal.
     *
     * @returns A new Literal with the same value, language, and datatype
     */
    clone(): Literal;
}

/**
 * RDF/JS-compatible NamedNode term.
 *
 * Named nodes represent IRIs (Internationalized Resource Identifiers) in RDF.
 * They are used to identify resources, properties, and datatypes.
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-IRIs | RDF 1.1 IRIs}
 * @see {@link https://rdf.js.org/data-model-spec/#namednode-interface | RDF/JS NamedNode}
 *
 * @example
 * ```typescript
 * // Create a named node for a person
 * const alice = namedNode('http://example.com/alice');
 *
 * // Use with common vocabularies
 * const foafName = namedNode('http://xmlns.com/foaf/0.1/name');
 * const rdfType = namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
 *
 * // Create a triple
 * store.add(quad(alice, foafName, literal('Alice')));
 * ```
 */
export class NamedNode {
    /** Always "NamedNode" for named node terms */
    readonly termType: "NamedNode";

    /** The IRI string value */
    readonly value: string;

    /**
     * Checks if this named node equals another term.
     * Named nodes are equal if they have the same IRI.
     *
     * @param other - The term to compare with
     * @returns true if the terms are equal
     *
     * @example
     * ```typescript
     * const nn1 = namedNode('http://example.com/alice');
     * const nn2 = namedNode('http://example.com/alice');
     * const nn3 = namedNode('http://example.com/bob');
     * console.log(nn1.equals(nn2)); // true
     * console.log(nn1.equals(nn3)); // false
     * ```
     */
    equals(other: Term | null | undefined): boolean;

    /**
     * Returns a string representation of the named node.
     * Format: "<IRI>"
     *
     * @returns String representation with angle brackets
     *
     * @example
     * ```typescript
     * const nn = namedNode('http://example.com/alice');
     * console.log(nn.toString()); // "<http://example.com/alice>"
     * ```
     */
    toString(): string;

    /**
     * Returns the IRI value.
     * Alias for the value property.
     *
     * @returns The IRI string
     */
    valueOf(): string;

    /**
     * Returns a JSON representation of the named node.
     * Useful for serialization.
     *
     * @returns JSON object with termType and value
     *
     * @example
     * ```typescript
     * const nn = namedNode('http://example.com/alice');
     * console.log(JSON.stringify(nn));
     * // {"termType":"NamedNode","value":"http://example.com/alice"}
     * ```
     */
    toJSON(): { termType: "NamedNode"; value: string };

    /**
     * Creates a shallow copy of the named node.
     *
     * @returns A new NamedNode with the same IRI
     */
    clone(): NamedNode;
}

/**
 * BaseQuad is part of the RDF/JS spec and has no direct equivalent in Oxigraph.
 * 
 * It's copied here from the RDF/JS reference types (https://github.com/rdfjs/types , MIT license) because:
 *  - RDF/JS DatasetCore's match method takes Term parameters.
 *  - RDF/JS's Term is defined in terms of BaseQuad and not Quad.
 */ 
export interface BaseQuad {
    readonly graph: Term;
    readonly object: Term;
    readonly predicate: Term;
    readonly subject: Term;
    readonly termType: "Quad";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
}

/**
 * RDF/JS-compatible Quad term.
 *
 * A quad (or RDF statement) is the fundamental unit of RDF data.
 * It consists of a subject, predicate, object, and optionally a graph name.
 * Without a graph name (using DefaultGraph), it represents an RDF triple.
 *
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-triples | RDF 1.1 Triples}
 * @see {@link https://www.w3.org/TR/rdf11-concepts/#section-dataset | RDF 1.1 Datasets}
 * @see {@link https://rdf.js.org/data-model-spec/#quad-interface | RDF/JS Quad}
 *
 * @example
 * ```typescript
 * // Create a simple triple (quad in default graph)
 * const triple = quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/name'),
 *   literal('Alice')
 * );
 *
 * // Create a quad in a named graph
 * const quadInGraph = quad(
 *   namedNode('http://example.com/alice'),
 *   namedNode('http://xmlns.com/foaf/0.1/knows'),
 *   namedNode('http://example.com/bob'),
 *   namedNode('http://example.com/socialGraph')
 * );
 *
 * // Add to store
 * store.add(triple);
 * store.add(quadInGraph);
 *
 * // Access components
 * console.log(triple.subject.value); // 'http://example.com/alice'
 * console.log(triple.predicate.value); // 'http://xmlns.com/foaf/0.1/name'
 * console.log(triple.object.value); // 'Alice'
 * console.log(triple.graph.termType); // 'DefaultGraph'
 * ```
 */
export class Quad implements BaseQuad {
    /**
     * The graph name (context) of the quad.
     * Can be a NamedNode, BlankNode, or DefaultGraph.
     * @readonly
     */
    readonly graph: Quad_Graph;

    /**
     * The object of the quad.
     * Can be any term: NamedNode, BlankNode, Literal, or nested Quad/Triple.
     * @readonly
     */
    readonly object: Quad_Object;

    /**
     * The predicate (property) of the quad.
     * Must be a NamedNode or Variable.
     * @readonly
     */
    readonly predicate: Quad_Predicate;

    /**
     * The subject of the quad.
     * Can be a NamedNode, BlankNode, Variable, or nested Quad/Triple.
     * @readonly
     */
    readonly subject: Quad_Subject;

    /** Always "Quad" for quad terms */
    readonly termType: "Quad";

    /** Always empty string for quads (RDF/JS spec) */
    readonly value: "";

    /**
     * Checks if this quad equals another term.
     * Quads are equal if all four components (subject, predicate, object, graph) are equal.
     *
     * @param other - The term to compare with
     * @returns true if the quads are equal
     *
     * @example
     * ```typescript
     * const q1 = quad(
     *   namedNode('http://example.com/alice'),
     *   namedNode('http://xmlns.com/foaf/0.1/name'),
     *   literal('Alice')
     * );
     * const q2 = quad(
     *   namedNode('http://example.com/alice'),
     *   namedNode('http://xmlns.com/foaf/0.1/name'),
     *   literal('Alice')
     * );
     * console.log(q1.equals(q2)); // true
     *
     * const q3 = quad(
     *   namedNode('http://example.com/bob'),
     *   namedNode('http://xmlns.com/foaf/0.1/name'),
     *   literal('Bob')
     * );
     * console.log(q1.equals(q3)); // false
     * ```
     */
    equals(other: Term | null | undefined): boolean;

    /**
     * Returns a string representation of the quad.
     * Format: "subject predicate object graph"
     *
     * @returns String representation
     *
     * @example
     * ```typescript
     * const q = quad(
     *   namedNode('http://example.com/alice'),
     *   namedNode('http://xmlns.com/foaf/0.1/name'),
     *   literal('Alice')
     * );
     * console.log(q.toString());
     * // <http://example.com/alice> <http://xmlns.com/foaf/0.1/name> "Alice" .
     * ```
     */
    toString(): string;

    /**
     * Returns the empty string (RDF/JS spec requirement).
     * Alias for the value property.
     *
     * @returns Empty string
     */
    valueOf(): string;

    /**
     * Returns a JSON representation of the quad.
     * Useful for serialization.
     *
     * @returns JSON object with termType, value, and all components
     *
     * @example
     * ```typescript
     * const q = quad(
     *   namedNode('http://example.com/alice'),
     *   namedNode('http://xmlns.com/foaf/0.1/name'),
     *   literal('Alice')
     * );
     * console.log(JSON.stringify(q));
     * // {"termType":"Quad","value":"","subject":{...},"predicate":{...},"object":{...},"graph":{...}}
     * ```
     */
    toJSON(): { termType: "Quad"; value: ""; subject: any; predicate: any; object: any; graph: any };

    /**
     * Creates a deep copy of the quad.
     *
     * @returns A new Quad with the same components
     */
    clone(): Quad;
}

/**
 * RDF-star Triple term (subject, predicate, object without graph)
 */
export class Triple {
    readonly object: Triple_Object;
    readonly predicate: Triple_Predicate;
    readonly subject: Triple_Subject;
    readonly termType: "Triple";
    readonly value: "";

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Triple"; value: ""; subject: any; predicate: any; object: any };
    clone(): Triple;
}

/**
 * Typedefs copied from the RDF/JS reference types (https://github.com/rdfjs/types)
 */
export type Quad_Graph = DefaultGraph | NamedNode | BlankNode | Variable;
export type Quad_Object = NamedNode | Literal | BlankNode | Quad | Triple | Variable;
export type Quad_Predicate = NamedNode | Variable;
export type Quad_Subject = NamedNode | BlankNode | Quad | Triple | Variable;

export type Triple_Object = NamedNode | Literal | BlankNode | Triple | Variable;
export type Triple_Predicate = NamedNode | Variable;
export type Triple_Subject = NamedNode | BlankNode | Triple | Variable;

/**
 * RDF/JS-compatible Term typedef. See note above re: BaseQuad.
 */
export type Term = NamedNode | BlankNode | Literal | Variable | DefaultGraph | BaseQuad | Triple;

/**
 * RDF/JS-compatible Variable term
 */
export class Variable {
    readonly termType: "Variable";
    readonly value: string;

    equals(other: Term | null | undefined): boolean;
    toString(): string;
    valueOf(): string;
    toJSON(): { termType: "Variable"; value: string };
    clone(): Variable;
}

/**
 * An in-memory RDF dataset
 *
 * It can accommodate a fairly large number of quads (in the few millions).
 *
 * Warning: It interns the strings and does not do any garbage collection yet:
 * if you insert and remove a lot of different terms, memory will grow without any reduction.
 */
export class Dataset {
    readonly size: number;

    constructor(quads?: Iterable<Quad>);

    add(quad: Quad): void;

    delete(quad: Quad): boolean;

    discard(quad: Quad): void;

    has(quad: Quad): boolean;

    includes(quad: Quad): boolean;

    match(subject?: Term | null, predicate?: Term | null, object?: Term | null, graph?: Term | null): Quad[];

    clear(): void;

    quadsForSubject(subject: Quad_Subject): Quad[];

    quadsForPredicate(predicate: Quad_Predicate): Quad[];

    quadsForObject(object: Quad_Object): Quad[];

    quadsForGraphName(graph: Quad_Graph): Quad[];

    canonicalize(algorithm: CanonicalizationAlgorithm): void;

    toString(): string;
    clone(): Dataset;

    forEach(callback: (quad: Quad) => void, thisArg?: any): void;
    filter(callback: (quad: Quad) => boolean, thisArg?: any): Dataset;
    some(callback: (quad: Quad) => boolean, thisArg?: any): boolean;
    every(callback: (quad: Quad) => boolean, thisArg?: any): boolean;
    find(callback: (quad: Quad) => boolean, thisArg?: any): Quad | undefined;
    toArray(): Quad[];
    map<T>(callback: (quad: Quad) => T, thisArg?: any): T[];
    reduce<T>(callback: (accumulator: T, quad: Quad) => T, initialValue: T): T;
    at(index: number): Quad | undefined;
    slice(start?: number, end?: number): Quad[];

    [Symbol.iterator](): Iterator<Quad>;
}
"###;

#[wasm_bindgen(js_name = namedNode)]
pub fn named_node(value: String) -> Result<JsNamedNode, JsValue> {
    NamedNode::new(value)
        .map(Into::into)
        .map_err(|v| UriError::new(&v.to_string()).into())
}

#[wasm_bindgen(js_name = blankNode)]
pub fn blank_node(value: Option<String>) -> Result<JsBlankNode, JsError> {
    Ok(if let Some(value) = value {
        BlankNode::new(value)?
    } else {
        BlankNode::default()
    }
    .into())
}

#[wasm_bindgen(skip_typescript)]
pub fn literal(
    value: Option<String>,
    language_or_datatype: &JsValue,
) -> Result<JsLiteral, JsValue> {
    if language_or_datatype.is_null() || language_or_datatype.is_undefined() {
        Ok(Literal::new_simple_literal(value.unwrap_or_default()).into())
    } else if language_or_datatype.is_string() {
        Ok(Literal::new_language_tagged_literal(
            value.unwrap_or_default(),
            language_or_datatype.as_string().unwrap_or_default(),
        )
        .map_err(JsError::from)?
        .into())
    } else {
        let language = Reflect::get(language_or_datatype, &JsValue::from_str("language"))?;
        if language.is_undefined() {
            if let JsTerm::NamedNode(datatype) =
                FROM_JS.with(|c| c.to_term(language_or_datatype))?
            {
                Ok(Literal::new_typed_literal(value.unwrap_or_default(), datatype).into())
            } else {
                Err(format_err!("The literal datatype should be a NamedNode"))
            }
        } else if let Some(direction) =
            Reflect::get(language_or_datatype, &JsValue::from_str("direction"))?.as_string()
        {
            #[cfg(feature = "rdf-12")]
            {
                Ok(Literal::new_directional_language_tagged_literal(
                    value.unwrap_or_default(),
                    language.as_string().unwrap_or_default(),
                    match direction.as_str() {
                        "ltr" => BaseDirection::Ltr,
                        "rtl" => BaseDirection::Rtl,
                        dir => return Err(format_err!("Invalid direction: {dir}")),
                    },
                )
                .map_err(JsError::from)?
                .into())
            }
            #[cfg(not(feature = "rdf-12"))]
            {
                Err(format_err!(
                    "RDF 1.2 is not enabled, {direction} direction is not supported"
                ))
            }
        } else {
            Ok(Literal::new_language_tagged_literal(
                value.unwrap_or_default(),
                language.as_string().unwrap_or_default(),
            )
            .map_err(JsError::from)?
            .into())
        }
    }
}

#[wasm_bindgen(js_name = defaultGraph)]
pub fn default_graph() -> JsDefaultGraph {
    JsDefaultGraph
}

#[wasm_bindgen(js_name = variable)]
pub fn variable(value: String) -> Result<JsVariable, JsError> {
    Ok(Variable::new(value)?.into())
}

#[wasm_bindgen(js_name = triple, skip_typescript)]
pub fn triple(
    subject: &JsValue,
    predicate: &JsValue,
    object: &JsValue,
) -> Result<JsTriple, JsValue> {
    Ok(FROM_JS
        .with(|c| c.to_triple_from_parts(subject, predicate, object))?
        .into())
}

#[wasm_bindgen(js_name = quad, skip_typescript)]
pub fn quad(
    subject: &JsValue,
    predicate: &JsValue,
    object: &JsValue,
    graph: &JsValue,
) -> Result<JsQuad, JsValue> {
    Ok(FROM_JS
        .with(|c| c.to_quad_from_parts(subject, predicate, object, graph))?
        .into())
}

#[wasm_bindgen(js_name = fromTerm)]
pub fn from_term(original: &JsValue) -> Result<JsValue, JsValue> {
    Ok(if original.is_null() {
        JsValue::NULL
    } else {
        FROM_JS.with(|c| c.to_term(original))?.into()
    })
}

#[wasm_bindgen(js_name = fromQuad)]
pub fn from_quad(original: &JsValue) -> Result<JsValue, JsValue> {
    Ok(if original.is_null() {
        JsValue::NULL
    } else {
        JsQuad::from(FROM_JS.with(|c| c.to_quad(original))?).into()
    })
}

#[wasm_bindgen(js_name = NamedNode, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsNamedNode {
    inner: NamedNode,
}

#[wasm_bindgen(js_class = NamedNode)]
impl JsNamedNode {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "NamedNode".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::NamedNode(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"NamedNode".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<NamedNode> for JsNamedNode {
    fn from(inner: NamedNode) -> Self {
        Self { inner }
    }
}

impl From<JsNamedNode> for NamedNode {
    fn from(node: JsNamedNode) -> Self {
        node.inner
    }
}

impl From<JsNamedNode> for NamedOrBlankNode {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

impl From<JsNamedNode> for Term {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

impl From<JsNamedNode> for GraphName {
    fn from(node: JsNamedNode) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = BlankNode, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsBlankNode {
    inner: BlankNode,
}

#[wasm_bindgen(js_class = BlankNode)]
impl JsBlankNode {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "BlankNode".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::BlankNode(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"BlankNode".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<BlankNode> for JsBlankNode {
    fn from(inner: BlankNode) -> Self {
        Self { inner }
    }
}

impl From<JsBlankNode> for BlankNode {
    fn from(node: JsBlankNode) -> Self {
        node.inner
    }
}

impl From<JsBlankNode> for NamedOrBlankNode {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

impl From<JsBlankNode> for Term {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

impl From<JsBlankNode> for GraphName {
    fn from(node: JsBlankNode) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = Literal, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsLiteral {
    inner: Literal,
}

#[wasm_bindgen(js_class = Literal)]
impl JsLiteral {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Literal".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.value().to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn language(&self) -> String {
        self.inner.language().unwrap_or("").to_owned()
    }

    #[cfg(feature = "rdf-12")]
    #[wasm_bindgen(getter)]
    pub fn direction(&self) -> String {
        self.inner
            .direction()
            .map_or_else(String::new, |d| d.to_string())
    }

    #[wasm_bindgen(getter)]
    pub fn datatype(&self) -> JsNamedNode {
        self.inner.datatype().into_owned().into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Literal(other))) = FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.value().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Literal".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.value().into()).unwrap();
        Reflect::set(&obj, &"datatype".into(), &self.datatype().to_json()).unwrap();
        if let Some(language) = self.inner.language() {
            Reflect::set(&obj, &"language".into(), &language.into()).unwrap();
        } else {
            Reflect::set(&obj, &"language".into(), &"".into()).unwrap();
        }
        #[cfg(feature = "rdf-12")]
        if let Some(direction) = self.inner.direction() {
            Reflect::set(&obj, &"direction".into(), &direction.to_string().into()).unwrap();
        } else {
            Reflect::set(&obj, &"direction".into(), &"".into()).unwrap();
        }
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Literal> for JsLiteral {
    fn from(inner: Literal) -> Self {
        Self { inner }
    }
}

impl From<JsLiteral> for Literal {
    fn from(node: JsLiteral) -> Self {
        node.inner
    }
}

impl From<JsLiteral> for Term {
    fn from(node: JsLiteral) -> Self {
        node.inner.into()
    }
}

#[wasm_bindgen(js_name = DefaultGraph, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]
pub struct JsDefaultGraph;

#[wasm_bindgen(js_class = DefaultGraph)]
impl JsDefaultGraph {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "DefaultGraph".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        "DEFAULT".to_owned()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::DefaultGraph(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"DefaultGraph".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        *self
    }
}

#[wasm_bindgen(js_name = Variable, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsVariable {
    inner: Variable,
}

#[wasm_bindgen(js_class = Variable)]
impl JsVariable {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Variable".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Variable(other))) =
            FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        self.inner.as_str().to_owned()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Variable".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &self.inner.as_str().into()).unwrap();
        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Variable> for JsVariable {
    fn from(inner: Variable) -> Self {
        Self { inner }
    }
}

impl From<JsVariable> for Variable {
    fn from(node: JsVariable) -> Self {
        node.inner
    }
}

#[wasm_bindgen(js_name = Triple, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsTriple {
    inner: Triple,
}

#[wasm_bindgen(js_class = Triple)]
impl JsTriple {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Triple".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(getter = subject)]
    pub fn subject(&self) -> JsValue {
        JsTerm::from(self.inner.subject.clone()).into()
    }

    #[wasm_bindgen(getter = predicate)]
    pub fn predicate(&self) -> JsValue {
        JsTerm::from(self.inner.predicate.clone()).into()
    }

    #[wasm_bindgen(getter = object)]
    pub fn object(&self) -> JsValue {
        JsTerm::from(self.inner.object.clone()).into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Triple(other))) = FromJsConverter::default().to_optional_term(other)
        {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Triple".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();

        // Convert subject, predicate, object to JSON
        match JsTerm::from(self.inner.subject.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"subject".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"subject".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"subject".into(), &t.to_json()).unwrap();
            }
            _ => {}
        }

        if let JsTerm::NamedNode(nn) = JsTerm::from(self.inner.predicate.clone()) {
            Reflect::set(&obj, &"predicate".into(), &nn.to_json()).unwrap();
        }

        match JsTerm::from(self.inner.object.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"object".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"object".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Literal(lit) => {
                Reflect::set(&obj, &"object".into(), &lit.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"object".into(), &t.to_json()).unwrap();
            }
            _ => {}
        }

        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Triple> for JsTriple {
    fn from(inner: Triple) -> Self {
        Self { inner }
    }
}

impl From<JsTriple> for Triple {
    fn from(triple: JsTriple) -> Self {
        triple.inner
    }
}

impl From<JsTriple> for Term {
    fn from(triple: JsTriple) -> Self {
        triple.inner.into()
    }
}

#[wasm_bindgen(js_name = Quad, skip_typescript)]
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub struct JsQuad {
    inner: Quad,
}

#[wasm_bindgen(js_class = Quad)]
impl JsQuad {
    #[wasm_bindgen(getter = termType)]
    pub fn term_type(&self) -> String {
        "Quad".to_owned()
    }

    #[wasm_bindgen(getter)]
    pub fn value(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(getter = subject)]
    pub fn subject(&self) -> JsValue {
        JsTerm::from(self.inner.subject.clone()).into()
    }

    #[wasm_bindgen(getter = predicate)]
    pub fn predicate(&self) -> JsValue {
        JsTerm::from(self.inner.predicate.clone()).into()
    }

    #[wasm_bindgen(getter = object)]
    pub fn object(&self) -> JsValue {
        JsTerm::from(self.inner.object.clone()).into()
    }

    #[wasm_bindgen(getter = graph)]
    pub fn graph(&self) -> JsValue {
        JsTerm::from(self.inner.graph_name.clone()).into()
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    pub fn equals(&self, other: &JsValue) -> bool {
        if let Ok(Some(JsTerm::Quad(other))) = FromJsConverter::default().to_optional_term(other) {
            self == &other
        } else {
            false
        }
    }

    #[wasm_bindgen(js_name = valueOf)]
    pub fn value_of(&self) -> String {
        String::new()
    }

    #[wasm_bindgen(js_name = toJSON)]
    pub fn to_json(&self) -> JsValue {
        let obj = js_sys::Object::new();
        Reflect::set(&obj, &"termType".into(), &"Quad".into()).unwrap();
        Reflect::set(&obj, &"value".into(), &"".into()).unwrap();

        // Convert subject, predicate, object, graph to JSON
        match JsTerm::from(self.inner.subject.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"subject".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"subject".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"subject".into(), &t.to_json()).unwrap();
            }
            JsTerm::Quad(q) => {
                Reflect::set(&obj, &"subject".into(), &q.to_json()).unwrap();
            }
            _ => {}
        }

        if let JsTerm::NamedNode(nn) = JsTerm::from(self.inner.predicate.clone()) {
            Reflect::set(&obj, &"predicate".into(), &nn.to_json()).unwrap();
        }

        match JsTerm::from(self.inner.object.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"object".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"object".into(), &bn.to_json()).unwrap();
            }
            JsTerm::Literal(lit) => {
                Reflect::set(&obj, &"object".into(), &lit.to_json()).unwrap();
            }
            JsTerm::Triple(t) => {
                Reflect::set(&obj, &"object".into(), &t.to_json()).unwrap();
            }
            JsTerm::Quad(q) => {
                Reflect::set(&obj, &"object".into(), &q.to_json()).unwrap();
            }
            _ => {}
        }

        match JsTerm::from(self.inner.graph_name.clone()) {
            JsTerm::NamedNode(nn) => {
                Reflect::set(&obj, &"graph".into(), &nn.to_json()).unwrap();
            }
            JsTerm::BlankNode(bn) => {
                Reflect::set(&obj, &"graph".into(), &bn.to_json()).unwrap();
            }
            JsTerm::DefaultGraph(dg) => {
                Reflect::set(&obj, &"graph".into(), &dg.to_json()).unwrap();
            }
            _ => {}
        }

        obj.into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }
}

impl From<Triple> for JsQuad {
    fn from(inner: Triple) -> Self {
        Self {
            inner: inner.in_graph(GraphName::DefaultGraph),
        }
    }
}

impl From<Quad> for JsQuad {
    fn from(inner: Quad) -> Self {
        Self { inner }
    }
}

impl From<JsQuad> for Quad {
    fn from(quad: JsQuad) -> Self {
        quad.inner
    }
}

impl From<JsQuad> for Triple {
    fn from(quad: JsQuad) -> Self {
        quad.inner.into()
    }
}

#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub enum JsTerm {
    NamedNode(JsNamedNode),
    BlankNode(JsBlankNode),
    Literal(JsLiteral),
    DefaultGraph(JsDefaultGraph),
    Variable(JsVariable),
    Triple(JsTriple),
    Quad(JsQuad),
}

impl From<JsTerm> for JsValue {
    fn from(value: JsTerm) -> Self {
        match value {
            JsTerm::NamedNode(v) => v.into(),
            JsTerm::BlankNode(v) => v.into(),
            JsTerm::Literal(v) => v.into(),
            JsTerm::DefaultGraph(v) => v.into(),
            JsTerm::Variable(v) => v.into(),
            JsTerm::Triple(v) => v.into(),
            JsTerm::Quad(v) => v.into(),
        }
    }
}

impl From<NamedNode> for JsTerm {
    fn from(node: NamedNode) -> Self {
        Self::NamedNode(node.into())
    }
}

impl From<BlankNode> for JsTerm {
    fn from(node: BlankNode) -> Self {
        Self::BlankNode(node.into())
    }
}

impl From<Literal> for JsTerm {
    fn from(literal: Literal) -> Self {
        Self::Literal(literal.into())
    }
}

impl From<NamedOrBlankNode> for JsTerm {
    fn from(node: NamedOrBlankNode) -> Self {
        match node {
            NamedOrBlankNode::NamedNode(node) => node.into(),
            NamedOrBlankNode::BlankNode(node) => node.into(),
        }
    }
}

impl From<Term> for JsTerm {
    fn from(term: Term) -> Self {
        match term {
            Term::NamedNode(node) => node.into(),
            Term::BlankNode(node) => node.into(),
            Term::Literal(literal) => literal.into(),
            #[cfg(feature = "rdf-12")]
            Term::Triple(node) => node.into(),
        }
    }
}

impl From<GraphName> for JsTerm {
    fn from(name: GraphName) -> Self {
        match name {
            GraphName::NamedNode(node) => node.into(),
            GraphName::BlankNode(node) => node.into(),
            GraphName::DefaultGraph => Self::DefaultGraph(JsDefaultGraph),
        }
    }
}

impl From<Variable> for JsTerm {
    fn from(variable: Variable) -> Self {
        Self::Variable(variable.into())
    }
}

impl From<Triple> for JsTerm {
    fn from(triple: Triple) -> Self {
        Self::Triple(triple.into())
    }
}

impl From<Box<Triple>> for JsTerm {
    fn from(triple: Box<Triple>) -> Self {
        Self::Triple(triple.as_ref().clone().into())
    }
}

impl From<Quad> for JsTerm {
    fn from(quad: Quad) -> Self {
        Self::Quad(quad.into())
    }
}

impl TryFrom<JsTerm> for NamedNode {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Err(format_err!(
                "The blank node {} is not a named node",
                node.inner
            )),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a named node",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Err(format_err!("The default graph is not a named node")),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a named node",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a named node",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!("The quad {} is not a named node", quad.inner)),
        }
    }
}

impl TryFrom<JsTerm> for NamedOrBlankNode {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a possible named or blank node term",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Err(format_err!(
                "The default graph is not a possible named or blank node term"
            )),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible named or blank node term",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible named or blank node term",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible named or blank node term",
                quad.inner
            )),
        }
    }
}

impl TryFrom<JsTerm> for Term {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Ok(literal.into()),
            JsTerm::DefaultGraph(_) => {
                Err(format_err!("The default graph is not a possible RDF term"))
            }
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible RDF term",
                variable.inner
            )),
            #[cfg(feature = "rdf-12")]
            JsTerm::Triple(triple) => Ok(triple.into()),
            #[cfg(not(feature = "rdf-12"))]
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible RDF term",
                triple.inner
            )),
            #[cfg(feature = "rdf-12")]
            JsTerm::Quad(quad) => Ok(Triple::from(quad).into()),
            #[cfg(not(feature = "rdf-12"))]
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible RDF term",
                quad.inner
            )),
        }
    }
}

impl TryFrom<JsTerm> for GraphName {
    type Error = JsValue;

    fn try_from(value: JsTerm) -> Result<Self, Self::Error> {
        match value {
            JsTerm::NamedNode(node) => Ok(node.into()),
            JsTerm::BlankNode(node) => Ok(node.into()),
            JsTerm::Literal(literal) => Err(format_err!(
                "The literal {} is not a possible graph name",
                literal.inner
            )),
            JsTerm::DefaultGraph(_) => Ok(Self::DefaultGraph),
            JsTerm::Variable(variable) => Err(format_err!(
                "The variable {} is not a possible RDF term",
                variable.inner
            )),
            JsTerm::Triple(triple) => Err(format_err!(
                "The triple {} is not a possible RDF term",
                triple.inner
            )),
            JsTerm::Quad(quad) => Err(format_err!(
                "The quad {} is not a possible RDF term",
                quad.inner
            )),
        }
    }
}

pub struct FromJsConverter {
    term_type: JsValue,
    value: JsValue,
    language: JsValue,
    #[cfg(feature = "rdf-12")]
    direction: JsValue,
    datatype: JsValue,
    subject: JsValue,
    predicate: JsValue,
    object: JsValue,
    graph: JsValue,
}

impl Default for FromJsConverter {
    fn default() -> Self {
        Self {
            term_type: JsValue::from_str("termType"),
            value: JsValue::from_str("value"),
            language: JsValue::from_str("language"),
            #[cfg(feature = "rdf-12")]
            direction: JsValue::from_str("direction"),
            datatype: JsValue::from_str("datatype"),
            subject: JsValue::from_str("subject"),
            predicate: JsValue::from_str("predicate"),
            object: JsValue::from_str("object"),
            graph: JsValue::from_str("graph"),
        }
    }
}

impl FromJsConverter {
    pub fn to_term(&self, value: &JsValue) -> Result<JsTerm, JsValue> {
        let term_type = Reflect::get(value, &self.term_type)?;
        if let Some(term_type) = term_type.as_string() {
            match term_type.as_str() {
                "NamedNode" => Ok(NamedNode::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("NamedNode should have a string value"))?,
                )
                .map_err(|v| UriError::new(&v.to_string()))?
                .into()),
                "BlankNode" => Ok(BlankNode::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("BlankNode should have a string value"))?,
                )
                .map_err(JsError::from)?
                .into()),
                "Literal" => {
                    if let JsTerm::NamedNode(datatype) =
                        self.to_term(&Reflect::get(value, &self.datatype)?)?
                    {
                        let datatype = NamedNode::from(datatype);
                        let literal_value = Reflect::get(value, &self.value)?
                            .as_string()
                            .ok_or_else(|| format_err!("Literal should have a string value"))?;
                        Ok(match datatype.as_str() {
                                    "http://www.w3.org/2001/XMLSchema#string" => Literal::new_simple_literal(literal_value),
                                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" => Literal::new_language_tagged_literal(literal_value, Reflect::get(value, &self.language)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:langString datatype should have a language"),
                                    )?).map_err(JsError::from)?,
                                    #[cfg(feature = "rdf-12")]
                                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString" => Literal::new_directional_language_tagged_literal(literal_value, Reflect::get(value, &self.language)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:dirLangString datatype should have a language"),
                                    )?, match Reflect::get(value, &self.direction)?.as_string().ok_or_else(
                                        || format_err!("Literal with rdf:dirLangString datatype should have a direction"),
                                    )?.as_str() {
                                        "ltr" => BaseDirection::Ltr,
                                        "rtl" => BaseDirection::Rtl,
                                        dir => return Err(format_err!("Invalid direction: {dir}")),
                                    }).map_err(JsError::from)?,
                                    _ => Literal::new_typed_literal(literal_value, datatype)
                                }.into())
                    } else {
                        Err(format_err!(
                            "Literal should have a datatype that is a NamedNode"
                        ))
                    }
                }
                "DefaultGraph" => Ok(JsTerm::DefaultGraph(JsDefaultGraph)),
                "Variable" => Ok(Variable::new(
                    Reflect::get(value, &self.value)?
                        .as_string()
                        .ok_or_else(|| format_err!("Variable should have a string value"))?,
                )
                .map_err(JsError::from)?
                .into()),
                "Triple" => Ok(self.to_triple(value)?.into()),
                "Quad" => Ok(self.to_quad(value)?.into()),
                _ => Err(format_err!(
                    "The termType {term_type} is not supported by Oxigraph"
                )),
            }
        } else if term_type.is_undefined() {
            // It's a quad without the proper type
            if Reflect::has(value, &self.subject)?
                && Reflect::has(value, &self.predicate)?
                && Reflect::has(value, &self.object)?
            {
                Ok(self.to_quad(value)?.into())
            } else {
                Err(format_err!(
                    "RDF term objects should have a termType attribute"
                ))
            }
        } else {
            Err(format_err!("The object termType field should be a string"))
        }
    }

    pub fn to_optional_term(&self, value: &JsValue) -> Result<Option<JsTerm>, JsValue> {
        if value.is_null() || value.is_undefined() {
            Ok(None)
        } else {
            self.to_term(value).map(Some)
        }
    }

    pub fn to_quad(&self, value: &JsValue) -> Result<Quad, JsValue> {
        self.to_quad_from_parts(
            &Reflect::get(value, &self.subject)?,
            &Reflect::get(value, &self.predicate)?,
            &Reflect::get(value, &self.object)?,
            &Reflect::get(value, &self.graph)?,
        )
    }

    pub fn to_quad_from_parts(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
        graph_name: &JsValue,
    ) -> Result<Quad, JsValue> {
        Ok(Quad {
            subject: NamedOrBlankNode::try_from(self.to_term(subject)?)?,
            predicate: NamedNode::try_from(self.to_term(predicate)?)?,
            object: Term::try_from(self.to_term(object)?)?,
            graph_name: if graph_name.is_undefined() {
                GraphName::DefaultGraph
            } else {
                GraphName::try_from(self.to_term(graph_name)?)?
            },
        })
    }

    pub fn to_triple(&self, value: &JsValue) -> Result<Triple, JsValue> {
        self.to_triple_from_parts(
            &Reflect::get(value, &self.subject)?,
            &Reflect::get(value, &self.predicate)?,
            &Reflect::get(value, &self.object)?,
        )
    }

    pub fn to_triple_from_parts(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
    ) -> Result<Triple, JsValue> {
        Ok(Triple {
            subject: NamedOrBlankNode::try_from(self.to_term(subject)?)?,
            predicate: NamedNode::try_from(self.to_term(predicate)?)?,
            object: Term::try_from(self.to_term(object)?)?,
        })
    }
}

#[wasm_bindgen(js_name = Dataset, skip_typescript)]
pub struct JsDataset {
    inner: Dataset,
}

#[wasm_bindgen(js_class = Dataset)]
impl JsDataset {
    #[wasm_bindgen(constructor)]
    pub fn new(quads: &JsValue) -> Result<JsDataset, JsValue> {
        let mut inner = Dataset::new();
        if !quads.is_undefined() && !quads.is_null() {
            if let Some(quads) = try_iter(quads)? {
                for quad in quads {
                    inner.insert(&FROM_JS.with(|c| c.to_quad(&quad?))?);
                }
            }
        }
        Ok(Self { inner })
    }

    pub fn add(&mut self, quad: &JsValue) -> Result<(), JsValue> {
        self.inner.insert(&FROM_JS.with(|c| c.to_quad(quad))?);
        Ok(())
    }

    pub fn delete(&mut self, quad: &JsValue) -> Result<bool, JsValue> {
        Ok(self.inner.remove(&FROM_JS.with(|c| c.to_quad(quad))?))
    }

    pub fn discard(&mut self, quad: &JsValue) -> Result<(), JsValue> {
        self.inner.remove(&FROM_JS.with(|c| c.to_quad(quad))?);
        Ok(())
    }

    pub fn has(&self, quad: &JsValue) -> Result<bool, JsValue> {
        Ok(self.inner.contains(&FROM_JS.with(|c| c.to_quad(quad))?))
    }

    pub fn includes(&self, quad: &JsValue) -> Result<bool, JsValue> {
        self.has(quad)
    }

    #[wasm_bindgen(getter = size)]
    pub fn size(&self) -> usize {
        self.inner.len()
    }

    #[wasm_bindgen(js_name = match)]
    pub fn match_quads(
        &self,
        subject: &JsValue,
        predicate: &JsValue,
        object: &JsValue,
        graph_name: &JsValue,
    ) -> Result<Box<[JsValue]>, JsValue> {
        let subject = if let Some(subject) = FROM_JS.with(|c| c.to_optional_term(subject))? {
            Some(NamedOrBlankNode::try_from(subject)?)
        } else {
            None
        };
        let predicate = if let Some(predicate) = FROM_JS.with(|c| c.to_optional_term(predicate))? {
            Some(NamedNode::try_from(predicate)?)
        } else {
            None
        };
        let object = if let Some(object) = FROM_JS.with(|c| c.to_optional_term(object))? {
            Some(Term::try_from(object)?)
        } else {
            None
        };
        let graph_name =
            if let Some(graph_name) = FROM_JS.with(|c| c.to_optional_term(graph_name))? {
                Some(GraphName::try_from(graph_name)?)
            } else {
                None
            };

        let quads: Vec<JsValue> = self
            .inner
            .iter()
            .filter(|quad| {
                (subject.is_none() || subject.as_ref().map(|s| s.as_ref()) == Some(quad.subject))
                    && (predicate.is_none()
                        || predicate.as_ref().map(|p| p.as_ref()) == Some(quad.predicate))
                    && (object.is_none()
                        || object.as_ref().map(|o| o.as_ref()) == Some(quad.object))
                    && (graph_name.is_none()
                        || graph_name.as_ref().map(|g| g.as_ref()) == Some(quad.graph_name))
            })
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect();

        Ok(quads.into_boxed_slice())
    }

    pub fn clear(&mut self) {
        self.inner.clear();
    }

    #[wasm_bindgen(js_name = quadsForSubject)]
    pub fn quads_for_subject(&self, subject: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let subject = FROM_JS.with(|c| c.to_term(subject))?;
        let subject = NamedOrBlankNode::try_from(subject)?;
        Ok(self
            .inner
            .quads_for_subject(&subject)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForPredicate)]
    pub fn quads_for_predicate(&self, predicate: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let predicate = FROM_JS.with(|c| c.to_term(predicate))?;
        let predicate = NamedNode::try_from(predicate)?;
        Ok(self
            .inner
            .quads_for_predicate(&predicate)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForObject)]
    pub fn quads_for_object(&self, object: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let object = FROM_JS.with(|c| c.to_term(object))?;
        let object = Term::try_from(object)?;
        Ok(self
            .inner
            .quads_for_object(&object)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    #[wasm_bindgen(js_name = quadsForGraphName)]
    pub fn quads_for_graph_name(&self, graph_name: &JsValue) -> Result<Box<[JsValue]>, JsValue> {
        let graph_name = FROM_JS.with(|c| c.to_term(graph_name))?;
        let graph_name = GraphName::try_from(graph_name)?;
        Ok(self
            .inner
            .quads_for_graph_name(&graph_name)
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice())
    }

    pub fn canonicalize(&mut self, algorithm: &JsCanonicalizationAlgorithm) {
        self.inner.canonicalize((*algorithm).into());
    }

    #[wasm_bindgen(js_name = toString)]
    pub fn to_string(&self) -> String {
        self.inner.to_string()
    }

    // Symbol.iterator implementation - must be manually wired up in JavaScript
    // as wasm-bindgen doesn't support computed property names
    #[wasm_bindgen(skip_typescript)]
    pub fn __iterator(&self) -> JsValue {
        let quads: Vec<JsValue> = self
            .inner
            .iter()
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect();
        Array::from_iter(quads).values().into()
    }

    #[wasm_bindgen]
    pub fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
        }
    }

    // Collection methods for JavaScript compatibility
    #[wasm_bindgen(js_name = forEach)]
    pub fn for_each(&self, callback: &js_sys::Function, this_arg: &JsValue) -> Result<(), JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            callback.call1(&this, &quad_js)?;
        }
        Ok(())
    }

    #[wasm_bindgen]
    pub fn filter(
        &self,
        callback: &js_sys::Function,
        this_arg: &JsValue,
    ) -> Result<JsDataset, JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        let mut filtered = Dataset::new();
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.clone().into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                filtered.insert(&quad.into_owned());
            }
        }
        Ok(Self { inner: filtered })
    }

    #[wasm_bindgen]
    pub fn some(&self, callback: &js_sys::Function, this_arg: &JsValue) -> Result<bool, JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(true);
            }
        }
        Ok(false)
    }

    #[wasm_bindgen]
    pub fn every(&self, callback: &js_sys::Function, this_arg: &JsValue) -> Result<bool, JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if !callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(false);
            }
        }
        Ok(true)
    }

    #[wasm_bindgen]
    pub fn find(
        &self,
        callback: &js_sys::Function,
        this_arg: &JsValue,
    ) -> Result<JsValue, JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            if callback.call1(&this, &quad_js)?.is_truthy() {
                return Ok(quad_js);
            }
        }
        Ok(JsValue::UNDEFINED)
    }

    #[wasm_bindgen(js_name = toArray)]
    pub fn to_array(&self) -> Box<[JsValue]> {
        self.inner
            .iter()
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect::<Vec<_>>()
            .into_boxed_slice()
    }

    #[wasm_bindgen]
    pub fn map(
        &self,
        callback: &js_sys::Function,
        this_arg: &JsValue,
    ) -> Result<Box<[JsValue]>, JsValue> {
        let this = if this_arg.is_undefined() {
            JsValue::NULL
        } else {
            this_arg.clone()
        };
        let mut results = Vec::new();
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            let result = callback.call1(&this, &quad_js)?;
            results.push(result);
        }
        Ok(results.into_boxed_slice())
    }

    #[wasm_bindgen]
    pub fn reduce(
        &self,
        callback: &js_sys::Function,
        initial_value: JsValue,
    ) -> Result<JsValue, JsValue> {
        let mut accumulator = initial_value;
        for quad in self.inner.iter() {
            let quad_js: JsValue = JsQuad::from(quad.into_owned()).into();
            accumulator = callback.call2(&JsValue::NULL, &accumulator, &quad_js)?;
        }
        Ok(accumulator)
    }

    pub fn at(&self, index: i32) -> JsValue {
        let quads: Vec<_> = self.inner.iter().collect();
        let len = quads.len() as i32;
        let idx = if index < 0 { len + index } else { index };

        if idx < 0 || idx >= len {
            JsValue::UNDEFINED
        } else {
            JsQuad::from(quads[idx as usize].clone().into_owned()).into()
        }
    }

    #[wasm_bindgen]
    pub fn slice(&self, start: Option<i32>, end: Option<i32>) -> Box<[JsValue]> {
        let quads: Vec<JsValue> = self
            .inner
            .iter()
            .map(|quad| JsQuad::from(quad.into_owned()).into())
            .collect();

        let len = quads.len() as i32;
        let start = start.unwrap_or(0);
        let end = end.unwrap_or(len);

        let start = if start < 0 {
            (len + start).max(0)
        } else {
            start.min(len)
        } as usize;
        let end = if end < 0 {
            (len + end).max(0)
        } else {
            end.min(len)
        } as usize;

        quads[start..end.max(start)].to_vec().into_boxed_slice()
    }
}
